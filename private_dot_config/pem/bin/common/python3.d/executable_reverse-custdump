#!/usr/bin/env python3
# coding: utf-8

import re
import argparse
from dataclasses import dataclass
from enum import Enum
from typing import List
import sys
import pprint
import os
import sys

@dataclass
class MemoryDump:
    mCap: int
    mLen: int
    mContent: bytes
    mOffset: int
    is_valid: bool


    @classmethod
    def extract(cls, log_lines: List[str], offset = 0) -> 'MemoryDump':
        # memory_dump = MemoryDump()
        mLen = 0
        mCap = 0
        mContent: bytes = b''
        mOffset = 0
        is_valid = False
        for index, line in enumerate(log_lines[offset:]):
            # Extract mCap and mLen
            mOffset = index + offset
            if '[Dump]' in line and "'mCap'" in line and "'mLen'" in line :
                # print(f"Start process {mOffset}")
                match = re.search(r"'mCap'\s*:\s*(\d+);\s*'mLen'\s*:\s*(\d+)", line)
                if match:
                    mCap = int(match.group(1))
                    mLen = int(match.group(2))
            # Extract memory data
            elif "[dumpMemoryWithIndents]" in line and '[0x' in line:
                hex_strings = re.findall(r"(0x[0-9a-fA-F]{2})(?:,|$)", line)
                mContent += bytes(int(h, 16) for h in hex_strings)

                if len(mContent) == mLen or len(mContent) == mCap:
                    is_valid = True
                    break
        return cls(mCap, mLen, mContent, mOffset, is_valid) 

    @classmethod
    def extracts(cls, log_lines: List[str]) -> List['MemoryDump']:
        offset = 0
        ret = []
        while(offset < len(lines)):
            md = cls.extract(lines,offset)
            if md.is_valid:
                # print(md)
                offset = md.mOffset + 1
                ret.append(md)
            else:
                # print(md)
                break
        return ret

# if __name__ == "__main__":
    # log_data = [
    # ]
    # memory_dump = MemoryDump.extract(log_data)
    # import pprint
    # pprint.pprint(memory_dump)

def write_memory_dumps_to_file(memory_dumps, out_dir):
    os.makedirs(out_dir, exist_ok=True)
    for dump in memory_dumps:
        file_name = f"{out_dir}/{dump.mOffset}.bin"
        with open(file_name, 'wb') as f:
            # Writing the attributes to the file
            f.write(dump.mContent)


if __name__ == "__main__":
    # See: https://stackoverflow.com/questions/72236607/how-to-get-python-to-tolerate-utf-8-encoding-errors
    parser = argparse.ArgumentParser(description="Process some output directory.")
    parser.add_argument('-o', '--out_dir', help='Output directory (default: out)')
    args = parser.parse_args()
    
    lines = sys.stdin.buffer.read().decode(errors='replace').splitlines()
    msgs = MemoryDump.extracts(lines)
    pprint.pprint(msgs)
    
    if args.out_dir:
        write_memory_dumps_to_file(msgs, args.out_dir)



    

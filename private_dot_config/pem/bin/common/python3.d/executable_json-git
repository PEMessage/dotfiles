#!/usr/bin/env python3

import subprocess
import json
import re
import os
import pprint
import itertools
import hashlib
import argparse
import xml.etree.ElementTree as ElementTree


def git_log_json(argv: list, preargv=[]):
    RC_SPLITER = "|^=<<=^|"
    ATTR_SPLITER = "|^=@@=^|"
    format_map = {
        "hash": "%H",
        "parent": "%P",
        "subject": "%s",
        "ref": "%d",
        "body": "%b",
        "author_email": "%ae",
        "author_time": "%at",
    }

    format_str = ATTR_SPLITER.join(v for _, v in format_map.items())
    cmd = ['git'] + preargv + \
        ['log', f'--format={RC_SPLITER}{format_str}'] + argv

    try:
        info = subprocess.run(
            cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except subprocess.CalledProcessError as e:
        err_msg = {
            'returncode': e.returncode,
            'cmd': e.cmd,
            'stderr': e.stderr.decode('utf-8')
        }
        return {
            "type": "error",
            "content": err_msg
        }

    # 1. Raw stdout
    decoded = info.stdout.decode('utf-8')
    # ignore first empty record [ '' , record1 , record2 ... ]

    # 2. Split stdout to records
    records = [s.strip() for s in decoded.split(RC_SPLITER)[1:]]

    # 3. Split record to attribute
    for i, rc in enumerate(records):
        records[i] = rc.split(ATTR_SPLITER)

    # 4. turn record from list into dict
    for i, rc in enumerate(records):
        result = {}
        for j, k in enumerate(format_map.keys()):
            result[k] = rc[j]
        records[i] = result

    # 5. Try to find a changeid or calc one
    for rc in records:
        matched = re.search(r'Change-Id: (\S+)', rc["body"])

        if matched:
            rc["changeid"] = matched.group(1)
        else:
            hash_content = "||".join(
                [rc["subject"], rc["body"], rc["author_time"]])
            rc["changeid"] = hashlib.sha1(hash_content.encode(encoding='utf-8')).hexdigest() \
                + "||subject||body||author_time"

    return {
        "type": "log",
        "content": records
    }


def get_difference(a: list, b: list, key="changeid"):
    # key = "changeid"

    if a is None:
        a = []
    if b is None:
        b = []

    idsa = set(item[key] for item in a)
    idsb = set(item[key] for item in b)
    ids_cm = idsa & idsb

    # Create common dict
    ab_common = dict()
    for id in ids_cm:
        ab_common[id] = dict()

    a_only = []
    for item in a:
        id = item[key]
        if id in ids_cm:
            ab_common[id]["a"] = item
        else:
            a_only.append(item)

    b_only = []
    for item in b:
        id = item[key]
        if id in ids_cm:
            ab_common[id]["b"] = item
        else:
            b_only.append(item)

    return a_only, b_only, ab_common


def git_difflog_json(refA: str, refB: str, preargv=[]):
    atob = git_log_json([refA + '..' + refB], preargv)
    btoa = git_log_json([refB + '..' + refA], preargv)

    a_only, b_only, _ = get_difference(atob["content"], btoa["content"])
    return {
        "type": "difflog",
        "content": {
            "a_only": a_only,
            "b_only": b_only
        }
    }


def git_diffmani_json(ma: str, mb: str):

    manifests = {
        "a": ma,
        "b": mb
    }

    projects = {}

    for k, m in manifests.items():
        et = ElementTree.parse(m)
        default = et.find('default')
        if default is not None:
            default = default.attrib
        else:
            default = {}
        # pprint.pprint(default)
        # In Python 3.9.0 or greater: z = x | y
        # In Python 3.5 or greater: z = {**x, **y}
        # for others
        # def merge_two_dicts(x, y):
        #     z = x.copy()   # start with keys and values of x
        #     z.update(y)    # modifies z with keys and values of y
        #     return z

        # etpj: ElementTree.<project>
        pjs = [{**default, **etpj.attrib} for etpj in et.findall('project')]

        # try to format revision
        for pj in pjs:
            rev = pj["revision"]
            # pprint.pprint(pj)
            if rev.startswith('refs/'):
                continue
            elif re.match('[a-f0-9]{40}', rev):
                continue
            else:
                rev = '/'.join([pj["remote"], rev])
            pj["revision"] = rev

        projects[k] = pjs

    pjs_a_only, pjs_b_only, pjs_cm = get_difference(
        projects["a"], projects["b"], key="name")

    return {
        "type": "diffmani",
        "content": {
            "a_only": pjs_b_only,
            "b_only": pjs_a_only,
            "common": pjs_cm,
        }
    }


def git_diffall_json(ma: str, mb: str):
    projects = git_diffmani_json(ma, mb)["content"]["common"]

    def get_path(paths: list):
        for path in paths:
            if path and os.path.isdir(path):
                return path
        raise FileExistsError("'{}' is not dir".format(path))

    diff_projects = {}

    for name, pj in projects.items():
        # Skip loop if same revision
        reva = pj["a"].get("revision")
        revb = pj["b"].get("revision")
        if revb == reva:
            continue

        maybe_paths = [
            pj["b"].get("path"),
            pj["a"].get("path"),
            # your always sure to have name attribute
            name,
        ]
        pj_path = get_path(maybe_paths)

        diff = git_difflog_json(reva, revb, preargv=['-C', pj_path])["content"]
        if diff["a_only"] or diff["b_only"]:
            diff_projects["name"] = {
                "difflog": diff
            }

        # pprint.pprint(diff)

    return {
        "type": "diffall",
        "content": diff_projects
    }


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog='json-git')
    subparsers = parser.add_subparsers(
        help='support subcommand', dest='subcmd')

    # 1. git log wrapper
    parser_log = subparsers.add_parser('log', help='git log')

    # 2. git difflog (repect changeid)
    parser_difflog = subparsers.add_parser(
        'difflog', help='git diff FROMID TOID')
    parser_difflog.add_argument("refA")
    parser_difflog.add_argument("refB")

    # 3. git diffmanfest
    parser_diffmanifests = subparsers.add_parser(
        'diffmani', help='git diffmanifest')
    parser_diffmanifests.add_argument("refA")
    parser_diffmanifests.add_argument("refB")

    # 3. git all
    parser_all = subparsers.add_parser(
        'diffall', help='git diffall')
    parser_all.add_argument("refA")
    parser_all.add_argument("refB")

    opt, argv = parser.parse_known_args()

    if opt.subcmd == 'log':
        print(
            json.dumps(
                git_log_json(argv),
                indent=4
            )
        )
    elif opt.subcmd == 'difflog':
        print(
            json.dumps(
                git_difflog_json(opt.refA, opt.refB),
                indent=4
            )
        )
    elif opt.subcmd == 'diffmani':
        print(
            json.dumps(
                git_diffmani_json(opt.refA, opt.refB),
                indent=4
            )
        )
    elif opt.subcmd == 'diffall':
        print(
            json.dumps(
                git_diffall_json(opt.refA, opt.refB),
                indent=4
            )
        )
